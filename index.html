<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WhatsApp OCR — Name & Number Extractor</title>
  <style>
    body{font-family:Inter,system-ui,Arial;margin:18px;background:#0b1220;color:#eef2ff}
    .wrap{max-width:980px;margin:0 auto}
    .card{background:#0f172a;padding:18px;border-radius:10px;border:1px solid #162235}
    h1{margin:0 0 6px;font-size:20px}
    .muted{color:#9aa3b2;font-size:13px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
    input[type=file]{display:none}
    label.filebtn{padding:8px 12px;background:#0e1b2f;border-radius:8px;border:1px solid #263646;cursor:pointer}
    button{padding:8px 12px;border-radius:8px;border:1px solid #263646;background:#0e1b2f;color:#eef2ff;cursor:pointer}
    button.primary{background:linear-gradient(135deg,#10b981,#3b82f6);border:none}
    button.warn{background:#3b0d12;border:1px solid #6b1d1d}
    .preview{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
    img.preview-img{max-height:140px;border-radius:6px;border:1px solid #233148}
    table{width:100%;border-collapse:collapse;margin-top:12px;background:#071022}
    th,td{padding:8px;border-bottom:1px solid #132235;color:#e6eef8;text-align:left}
    th{background:#071728;font-weight:600}
    .status{margin-top:10px;color:#cfe9d9}
    .stats{display:flex;gap:8px;margin-top:10px}
    .statbox{background:#071425;padding:8px;border-radius:8px;border:1px solid #122635;flex:1}
    footer{margin-top:16px;color:#9aa3b2;font-size:13px;text-align:center}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>WhatsApp OCR — Name & Number Extractor</h1>
      <div class="muted">Upload screenshots of the group participants list (or paste OCR text). OCR runs in your browser — nothing is uploaded to a server.</div>

      <div class="controls">
        <label class="filebtn" for="fileInput">Choose image(s)</label>
        <input id="fileInput" type="file" accept="image/*" multiple />
        <button id="startBtn" class="primary">Start OCR & Extract</button>
        <button id="fromTextBtn">Extract from pasted text</button>
        <button id="clearBtn" class="warn">Clear</button>
        <button id="downloadBtn">Download CSV</button>
        <button id="copyBtn">Copy CSV</button>
      </div>

      <div style="margin-top:10px">
        <textarea id="pasteArea" style="width:100%;min-height:100px;background:#061225;border:1px solid #152034;padding:10px;color:#e6eef8;border-radius:6px" placeholder="(Optional) Paste OCR text here if you already have it..."></textarea>
      </div>

      <div class="preview" id="preview"></div>

      <div class="stats">
        <div class="statbox"><div class="muted">Total found</div><div id="totalFound">0</div></div>
        <div class="statbox"><div class="muted">Deduped</div><div id="deduped">0</div></div>
        <div class="statbox"><div class="muted">Invalid</div><div id="invalid">0</div></div>
      </div>

      <div class="status" id="status">Ready.</div>

      <table id="resultsTable" aria-hidden="true">
        <thead><tr><th>#</th><th>Name</th><th>Number</th></tr></thead>
        <tbody id="resultsBody"><tr><td colspan="3" style="color:#9aa3b2">No results yet.</td></tr></tbody>
      </table>

      <footer>
        Tips: For best results, use screenshots from WhatsApp Web (high-res) or zoom before taking the screenshot. If names still misread, try cropping to participants area or improve contrast.
      </footer>
    </div>
  </div>

  <!-- Tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
  <script>
  // ---------- Helpers ----------
  const PHONE_RX = /(\+?\d[\d\-\s()]{7,}\d)/g; // loose phone match
  const fileInput = document.getElementById('fileInput');
  const preview = document.getElementById('preview');
  const startBtn = document.getElementById('startBtn');
  const status = document.getElementById('status');
  const resultsBody = document.getElementById('resultsBody');
  const totalFoundEl = document.getElementById('totalFound');
  const dedupedEl = document.getElementById('deduped');
  const invalidEl = document.getElementById('invalid');
  const pasteArea = document.getElementById('pasteArea');
  const downloadBtn = document.getElementById('downloadBtn');
  const copyBtn = document.getElementById('copyBtn');
  const fromTextBtn = document.getElementById('fromTextBtn');
  const clearBtn = document.getElementById('clearBtn');

  let selectedFiles = [];
  let state = { rows: [] };

  fileInput.addEventListener('change', e => {
    selectedFiles = Array.from(e.target.files || []);
    renderPreview(selectedFiles);
  });

  function renderPreview(files){
    preview.innerHTML = '';
    files.forEach(f=>{
      const url = URL.createObjectURL(f);
      const img = document.createElement('img');
      img.src = url; img.className = 'preview-img';
      preview.appendChild(img);
    });
  }

  // Load image as Image object
  function loadImage(file){
    return new Promise((res, rej) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = ()=>{ URL.revokeObjectURL(url); res(img); };
      img.onerror = (e)=> rej(e);
      img.src = url;
    });
  }

  // Simple preprocessing: upscale, grayscale, mild contrast and optional threshold
  function preprocessImageToCanvas(img, maxWidth=1400){
    const scale = Math.max(1, Math.min(2.5, maxWidth / img.width));
    const w = Math.round(img.width * scale);
    const h = Math.round(img.height * scale);
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    const ctx = c.getContext('2d');
    // draw with smoothing off for text
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(img, 0, 0, w, h);

    // get image data and apply mild contrast + grayscale
    try {
      const id = ctx.getImageData(0,0,w,h);
      const d = id.data;
      // contrast factor: -50..+50 (tweakable)
      const contrast = 18;
      const f = (259 * (contrast + 255)) / (255 * (259 - contrast));
      for(let i=0;i<d.length;i+=4){
        // grayscale
        const gray = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
        // contrast
        let v = f * (gray - 128) + 128;
        // optional light thresholding
        // v = v < 200 ? v : 255;
        d[i] = d[i+1] = d[i+2] = v;
      }
      ctx.putImageData(id,0,0);
    } catch(err){ /* some browsers restrict huge canvases; just proceed without preprocessing */ console.warn('preprocess failed',err) }

    return c;
  }

  // Robust OCR wrapper: use worker if available, otherwise fallback to Tesseract.recognize
  async function ocrCanvas(canvas, onprogress){
    if (typeof Tesseract !== 'undefined' && typeof Tesseract.createWorker === 'function'){
      const worker = Tesseract.createWorker({
        logger: m => {
          if (onprogress) onprogress(m);
        }
      });
      try {
        await worker.load();
        await worker.loadLanguage('eng');
        await worker.initialize('eng');
        // prefer a PSM that works well for blocks of text
        try { await worker.setParameters({ tessedit_pageseg_mode: '6' }); } catch(e){/* ignore */ }
        const { data } = await worker.recognize(canvas);
        await worker.terminate();
        return data;
      } catch(err){
        // fall through to fallback
        console.warn('worker-based OCR failed, falling back:', err);
      }
    }

    // fallback
    if (typeof Tesseract !== 'undefined' && typeof Tesseract.recognize === 'function'){
      const res = await Tesseract.recognize(canvas, 'eng', {
        logger: m => { if (onprogress) onprogress(m); }
      });
      return res.data || res;
    }

    throw new Error('No Tesseract API available in this environment.');
  }

  function normalizeNumber(raw){
    if(!raw) return null;
    const s = String(raw).trim();
    const hasPlus = s.startsWith('+');
    const digits = s.replace(/[^0-9]/g,'');
    if(digits.length < 10 || digits.length > 15) return null;
    return (hasPlus ? '+' : '') + digits;
  }

  function cleanNameSegment(txt){
    if(!txt) return '';
    let t = String(txt).replace(/\u200c|\u200b/g,'');
    t = t.replace(PHONE_RX, '');
    t = t.replace(/[\[\](){}<>|•,:=_]/g,' ');
    t = t.replace(/\s+/g,' ').trim();
    t = t.replace(/^\(you\)\s*/i,'').replace(/\s*\(you\)$/i,'');
    // return only if some letters exist
    if(!/[A-Za-z\u00C0-\u024F\u0400-\u04FF]/.test(t)) return '';
    return t;
  }

  // Parse tesseract data into lines (prefer data.lines).
  function linesFromOCRData(data){
    if(!data) return [];
    if(Array.isArray(data.lines) && data.lines.length){
      return data.lines.map(l => ({ text: l.text.trim(), bbox: l.bbox || null }));
    }
    // fallback: split text
    const txt = data.text || data;
    return String(txt).split(/\r?\n/).map(s=>({ text: s.trim(), bbox: null})).filter(Boolean);
  }

  // Main pairing logic: more robust line-level pairing using OCR lines
  function extractPairsFromTextOCR(rawTextOrData){
    const lines = Array.isArray(rawTextOrData) ? rawTextOrData : linesFromOCRData(rawTextOrData);
    const resultsByNum = new Map();
    let totalFound = 0, invalid = 0;

    // First pass: lines that contain numbers
    for(let i=0; i<lines.length; i++){
      const line = lines[i].text || '';
      const matches = [...(line.matchAll(PHONE_RX))].map(m=>m[0]);
      totalFound += matches.length;
      for(const m of matches){
        const nrm = normalizeNumber(m);
        if(!nrm){ invalid++; continue; }
        // prefer name portion in same line: remove number substring(s) and leftover likely text
        const before = line.split(m)[0] || '';
        const after  = line.split(m)[1] || '';
        let name = cleanNameSegment(before) || cleanNameSegment(after) || '';
        // if still empty, look upward for nearest likely name (within previous 2 lines)
        if(!name){
          for(let j=i-1;j>=Math.max(0,i-3);j--){
            const cand = cleanNameSegment(lines[j].text || '');
            if(cand){ name = cand; break; }
          }
        }
        if(!name) name = 'Unknown';
        const existing = resultsByNum.get(nrm);
        if(!existing) resultsByNum.set(nrm, name);
        else {
          // prefer better name
          if(existing === 'Unknown' && name !== 'Unknown') resultsByNum.set(nrm, name);
          else if(name !== 'Unknown' && name.length > existing.length) resultsByNum.set(nrm, name);
        }
      }
    }

    // Second pass: handle lines like "Name" then later "Number" (if not caught above)
    for(let i=0;i<lines.length-1;i++){
      const a = cleanNameSegment(lines[i].text || '');
      const bMatches = [...((lines[i+1].text||'').matchAll(PHONE_RX))].map(m=>m[0]);
      if(a && bMatches.length){
        for(const m of bMatches){
          const nrm = normalizeNumber(m);
          if(!nrm){ invalid++; continue; }
          const existing = resultsByNum.get(nrm);
          if(!existing || existing==='Unknown' || a.length > existing.length) resultsByNum.set(nrm, a);
        }
      }
    }

    // Finalize order by first appearance
    const seenOrder = [];
    for(const line of lines){
      const nums = [...(line.text.matchAll(PHONE_RX))].map(m=>m[0]);
      for(const m of nums){
        const nrm = normalizeNumber(m);
        if(nrm && !seenOrder.includes(nrm)) seenOrder.push(nrm);
      }
    }
    // include any other keys
    for(const k of resultsByNum.keys()) if(!seenOrder.includes(k)) seenOrder.push(k);

    const rows = seenOrder.map(n => ({ name: resultsByNum.get(n) || 'Unknown', number: n }));
    const deduped = rows.length;
    const dupes = Math.max(0, totalFound - invalid - deduped);

    return { rows, totalFound, invalid, dupes };
  }

  // orchestrator for files -> OCR -> parse
  async function processSelectedFiles(files){
    status.textContent = 'Starting OCR...';
    let aggregateTextData = []; // we'll collect lines arrays per image in order
    let totalProgress = 0;
    for(let idx=0; idx<files.length; idx++){
      const file = files[idx];
      status.textContent = `Preparing image ${idx+1} / ${files.length}...`;
      const img = await loadImage(file);
      const canvas = preprocessImageToCanvas(img, 1400);
      status.textContent = `Running OCR on image ${idx+1} / ${files.length} ...`;
      const data = await ocrCanvas(canvas, m => {
        // progress logger
        if(m && m.status && m.progress!=null){
          status.textContent = `${m.status} ${Math.round(m.progress*100)}% (image ${idx+1}/${files.length})`;
        }
      });
      const lines = linesFromOCRData(data);
      aggregateTextData = aggregateTextData.concat(lines);
    }
    return aggregateTextData;
  }

  // UI render
  function renderResults(rows){
    resultsBody.innerHTML = '';
    if(!rows.length){
      resultsBody.innerHTML = '<tr><td colspan="3" style="color:#9aa3b2">No results found.</td></tr>';
      return;
    }
    rows.forEach((r,i)=>{
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${i+1}</td><td>${escapeHtml(r.name)}</td><td>${escapeHtml(r.number)}</td>`;
      resultsBody.appendChild(tr);
    });
  }

  function escapeHtml(s){ return String(s).replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

  // CSV helpers
  function rowsToCSV(rows){
    const header = 'S.No,Name,Number\n';
    const lines = rows.map((r,i)=>`${i+1},"${r.name.replace(/"/g,'""')}","${r.number.replace(/"/g,'""')}"`);
    return header + lines.join('\n') + (rows.length?'\n':'');
  }

  // Button handlers
  startBtn.addEventListener('click', async ()=>{
    if(!selectedFiles.length && !pasteArea.value.trim()){
      alert('Choose image(s) or paste OCR text first.');
      return;
    }
    try {
      let lines;
      if(selectedFiles.length){
        startBtn.disabled = true;
        const aggregatedLines = await processSelectedFiles(selectedFiles);
        lines = aggregatedLines;
        startBtn.disabled = false;
      } else {
        // use pasted text
        const txt = pasteArea.value || '';
        lines = String(txt).split(/\r?\n/).map(s=>({text:s.trim(), bbox:null})).filter(Boolean);
      }
      const { rows, totalFound, invalid, dupes } = extractPairsFromTextOCR(lines);
      state.rows = rows;
      totalFoundEl.textContent = totalFound;
      dedupedEl.textContent = rows.length;
      invalidEl.textContent = invalid;
      renderResults(rows);
      status.textContent = 'Done.';
    } catch(err){
      console.error(err);
      status.textContent = 'OCR failed: ' + (err && err.message ? err.message : err);
      startBtn.disabled = false;
    }
  });

  fromTextBtn.addEventListener('click', ()=>{
    const txt = pasteArea.value || '';
    if(!txt.trim()){ alert('Paste text first in the box.'); return; }
    const lines = String(txt).split(/\r?\n/).map(s=>({text:s.trim(), bbox:null})).filter(Boolean);
    const { rows, totalFound, invalid, dupes } = extractPairsFromTextOCR(lines);
    state.rows = rows;
    totalFoundEl.textContent = totalFound;
    dedupedEl.textContent = rows.length;
    invalidEl.textContent = invalid;
    renderResults(rows);
    status.textContent = 'Parsed text.';
  });

  downloadBtn.addEventListener('click', ()=>{
    if(!state.rows.length) return alert('No data to download.');
    const csv = rowsToCSV(state.rows);
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'whatsapp_group_members.csv';
    document.body.appendChild(a);
    a.click();
    a.remove();
  });

  copyBtn.addEventListener('click', async ()=>{
    if(!state.rows.length) return alert('No data to copy.');
    const csv = rowsToCSV(state.rows);
    try{ await navigator.clipboard.writeText(csv); alert('CSV copied to clipboard'); }
    catch(e){ alert('Copy failed'); }
  });

  clearBtn.addEventListener('click', ()=>{
    selectedFiles = [];
    fileInput.value = '';
    preview.innerHTML = '';
    pasteArea.value = '';
    state.rows = [];
    renderResults([]);
    totalFoundEl.textContent = '0';
    dedupedEl.textContent = '0';
    invalidEl.textContent = '0';
    status.textContent = 'Cleared.';
  });

  // Small UX: clicking the file label opens file chooser
  document.querySelector('.filebtn').addEventListener('click', ()=> fileInput.click());
  </script>
</body>
</html>
